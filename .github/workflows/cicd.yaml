name: Backend CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: acrdigitalgarage03.azurecr.io
  SERVICES: member,mysub,recommend

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [member, mysub, recommend]
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up JDK 21
      uses: actions/setup-java@v4
      with:
        java-version: '21'
        distribution: 'temurin'
    
    - name: Cache Gradle packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-
    
    - name: Grant execute permission for gradlew
      run: chmod +x gradlew
    
    - name: Build with Gradle
      run: |
        if [ "${{ matrix.service }}" = "mysub" ]; then
          ./gradlew :mysub-infra:clean :mysub-infra:build -x test
        else
          ./gradlew :${{ matrix.service }}:clean :${{ matrix.service }}:build -x test
        fi
    
    - name: Run tests and generate coverage report
      run: |
        if [ "${{ matrix.service }}" = "mysub" ]; then
          ./gradlew :mysub-infra:test :mysub-infra:jacocoTestReport
        else
          ./gradlew :${{ matrix.service }}:test :${{ matrix.service }}:jacocoTestReport
        fi
    
    - name: SonarQube Scan
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      run: |
        if [ "${{ matrix.service }}" = "mysub" ]; then
          ./gradlew :mysub-infra:sonar \
            -Dsonar.projectKey=lifesub-${{ matrix.service }}-dg0420 \
            -Dsonar.projectName=lifesub-${{ matrix.service }}-dg0420 \
            -Dsonar.host.url="${{ secrets.SONAR_HOST_URL }}" \
            -Dsonar.login="${{ secrets.SONAR_TOKEN }}" \
            -Dsonar.java.binaries=build/classes/java/main \
            -Dsonar.coverage.jacoco.xmlReportPaths=build/reports/jacoco/test/jacocoTestReport.xml \
            -Dsonar.exclusions=**/config/**,**/entity/**,**/dto/**,**/*Application.class,**/exception/**
        else
          ./gradlew :${{ matrix.service }}:sonar \
            -Dsonar.projectKey=lifesub-${{ matrix.service }}-dg0420 \
            -Dsonar.projectName=lifesub-${{ matrix.service }}-dg0420 \
            -Dsonar.host.url="${{ secrets.SONAR_HOST_URL }}" \
            -Dsonar.login="${{ secrets.SONAR_TOKEN }}" \
            -Dsonar.java.binaries=build/classes/java/main \
            -Dsonar.coverage.jacoco.xmlReportPaths=build/reports/jacoco/test/jacocoTestReport.xml \
            -Dsonar.exclusions=**/config/**,**/entity/**,**/dto/**,**/*Application.class,**/exception/**
        fi
    
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.service }}-jar
        path: |
          ${{ matrix.service == 'mysub' && 'mysub-infra' || matrix.service }}/build/libs/*.jar
        retention-days: 1

  release:
    needs: build
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.generate-tag.outputs.image-tag }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Read deployment environment variables
      run: |
        while IFS='=' read -r key value; do
          # Skip comments and empty lines
          if [[ ! "$key" =~ ^#.*$ ]] && [[ -n "$key" ]] && [[ -n "$value" ]]; then
            echo "$key=$value" >> $GITHUB_ENV
          fi
        done < deployment/deploy_env_vars
    
    - name: Generate image tag
      id: generate-tag
      run: |
        IMAGE_TAG=$(date +'%Y%m%d%H%M%S')
        echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
    
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        pattern: "*-jar"
        merge-multiple: true
    
    - name: Login to Azure Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.registry }}
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}
    
    - name: Build and push Docker images
      run: |
        for service in member mysub recommend; do
          if [ "$service" = "mysub" ]; then
            BUILD_LIB_DIR="mysub-infra/build/libs"
            JAR_FILE="mysub.jar"
            # Find the actual JAR file and rename it
            ACTUAL_JAR=$(find mysub-infra/build/libs -name "*.jar" | head -n 1)
            if [ -n "$ACTUAL_JAR" ]; then
              cp "$ACTUAL_JAR" "mysub-infra/build/libs/mysub.jar"
            fi
          else
            BUILD_LIB_DIR="$service/build/libs"
            JAR_FILE="$service.jar"
            # Find the actual JAR file and rename it
            ACTUAL_JAR=$(find $service/build/libs -name "*.jar" | head -n 1)
            if [ -n "$ACTUAL_JAR" ]; then
              cp "$ACTUAL_JAR" "$service/build/libs/$service.jar"
            fi
          fi
          
          echo "Building image for $service..."
          docker build \
            --build-arg BUILD_LIB_DIR="$BUILD_LIB_DIR" \
            --build-arg ARTIFACTORY_FILE="$JAR_FILE" \
            -f deployment/container/Dockerfile \
            -t ${{ env.registry }}/${{ env.image_org }}/$service:${{ env.IMAGE_TAG }} .
          
          echo "Pushing image for $service..."
          docker push ${{ env.registry }}/${{ env.image_org }}/$service:${{ env.IMAGE_TAG }}
        done

  deploy:
    needs: [build, release]
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Read deployment environment variables
      run: |
        while IFS='=' read -r key value; do
          # Skip comments and empty lines
          if [[ ! "$key" =~ ^#.*$ ]] && [[ -n "$key" ]] && [[ -n "$value" ]]; then
            echo "$key=$value" >> $GITHUB_ENV
          fi
        done < deployment/deploy_env_vars
    
    - name: Set image tag from release job
      run: |
        echo "IMAGE_TAG=${{ needs.release.outputs.image-tag }}" >> $GITHUB_ENV
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
    
    - name: Get AKS credentials
      run: |
        az aks get-credentials --resource-group rg-digitalgarage-03 --name aks-digitalgarage-03 --overwrite-existing
    
    - name: Create namespace
      run: |
        kubectl create namespace ${{ env.namespace }} --dry-run=client -o yaml | kubectl apply -f -
    
    - name: Generate Kubernetes manifests
      run: |
        # Set image paths as environment variables
        export member_image_path="${{ env.registry }}/${{ env.image_org }}/member:${{ env.IMAGE_TAG }}"
        export mysub_image_path="${{ env.registry }}/${{ env.image_org }}/mysub:${{ env.IMAGE_TAG }}"
        export recommend_image_path="${{ env.registry }}/${{ env.image_org }}/recommend:${{ env.IMAGE_TAG }}"
        
        # Generate manifest from template
        envsubst < deployment/deploy.yaml.template > deployment/deploy.yaml
        
        echo "=== Generated Manifest ==="
        cat deployment/deploy.yaml
        echo "=========================="
    
    - name: Deploy to AKS
      run: |
        kubectl apply -f deployment/deploy.yaml
        
        echo "Waiting for deployments to be ready..."
        kubectl -n ${{ env.namespace }} wait --for=condition=available deployment/member --timeout=300s
        kubectl -n ${{ env.namespace }} wait --for=condition=available deployment/mysub --timeout=300s
        kubectl -n ${{ env.namespace }} wait --for=condition=available deployment/recommend --timeout=300s
        
        echo "=========================="
        echo "Backend Deployment Completed!"
        echo "Services:"
        kubectl -n ${{ env.namespace }} get svc
        echo "=========================="
